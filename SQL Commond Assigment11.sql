use sakila;
##Q2- List all details of actors
select *from actor;

##Q3 -List all customer information from DB.
select *from customer;

##Q4 -List different countries
select *from country;

##Q5 -Display all active customers.
select first_name , last_name, active from customer
where active =1;

##Q6 -List of all rental IDs for customer with ID 1.

select *from rental;
select rental_id , customer_id from rental
where customer_id =1;

##Q7 - Display all the films whose rental duration is greater than 5 .
select *from film;
select title , rental_duration
from film where rental_duration > 5;

##Q8 - List the total number of films whose replacement cost is greater than $15 and less than $20
select title, replacement_cost from film
where replacement_cost >15 and replacement_cost<20;

##Q9 - Display the count of unique first names of actors
select count(distinct first_name) as unique_name from actor;

##Q10- Display the first 10 records from the customer table .
select *from customer limit 10;

##Q11 - Display the first 3 records from the customer table whose first name starts with ‘b’.
select *from customer 
where first_name like 'b%'
limit 3;

##Q12 -Display the names of the first 5 movies which are rated as ‘G’.
select *from film
where rating = 'G' limit 5;

##Q13-Find all customers whose first name starts with "a".
select *from customer
where first_name like 'a%';

##Q14- Find all customers whose first name ends with "a".
select *from customer 
where first_name like '%a';

##Q15- Display the list of first 4 cities which start and end with ‘a’ .
select *from city
where city like 'a%' and city like '%a';

##Q16- Find all customers whose first name have "NI" in any position.
select *from  customer
where first_name like '%NI%';

##Q17- Find all customers whose first name have "r" in the second position .
select *from customer 
where first_name like '_r%';

##Q18 - Find all customers whose first name starts with "a" and are at least 5 characters in length.
select *from customer 
where first_name like 'a____';

##Q19- Find all customers whose first name starts with "a" and ends with "o".
select *from customer
where first_name like 'a%o';

select *from customer
where first_name like 'a%' and first_name like '%o';

##Q20 - Get the films with pg and pg-13 rating using IN operator.
select *from film
where rating in ('pg', 'pg-13');

##Q21 - Get the films with length between 50 to 100 using between operator
select *from film
where length between 50 and 100;

##Q22 - Get the top 50 actors using limit operator.
 select *from actor
 limit 50;
 
 ##Q23 - Get the distinct film ids from inventory table.
 select distinct film_id from inventory;
 
 ##Functions
 
 /*Question 1:Retrieve the total number of rentals made in the Sakila database.
Hint: Use the COUNT() function.*/
select count(rental_id) from rental;

/*Question 2:
Find the average rental duration (in days) of movies rented from the Sakila database.
Hint: Utilize the AVG() function.*/
select avg(rental_duration) from film;

/*String Functions:
Question 3:
Display the first name and last name of customers in uppercase.
Hint: Use the UPPER () function*/
select *from customer;
select upper(first_name)  as upper_first_name ,
upper(last_name) as upper_last_name from customer;

/*Question 4:
Extract the month from the rental date and display it alongside the rental ID.
Hint: Employ the MONTH() function.*/
select *from rental;
select month(rental_date) as month_rental_date , rental_id from rental;

/*GROUP BY:

Question 5:
Retrieve the count of rentals for each customer (display customer ID and the count of rentals).
Hint: Use COUNT () in conjunction with GROUP BY.*/
select *from rental;
select *from customer;
select customer_id, count(rental_id) from rental
group by customer_id;

/*Question 6:
Find the total revenue generated by each store.
Hint: Combine SUM() and GROUP BY.*/
select *from payment;
select sum(amount) as total_revenue 
from payment group by payment_id;

/*Question 7:
Determine the total number of rentals for each category of movies.
Hint: JOIN film_category, film, and rental tables, then use cOUNT () and GROUP BY.*/
select *from film;
SELECT c.name AS category_name,
       COUNT(r.rental_id) AS total_rentals
FROM category c
JOIN film_category fc ON c.category_id = fc.category_id
JOIN film f ON fc.film_id = f.film_id
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
GROUP BY c.name
ORDER BY total_rentals DESC;

/*Question 8:
Find the average rental rate of movies in each language.
Hint: JOIN film and language tables, then use AVG () and GROUP BY.*/
SELECT l.name AS language_name,
       AVG(f.rental_rate) AS average_rental_rate
FROM film f
JOIN language l ON f.language_id = l.language_id
GROUP BY l.name
ORDER BY average_rental_rate DESC;

/* Joins
Questions 9 -
Display the title of the movie, customer s first name, and last name who rented it.
Hint: Use JOIN between the film, inventory, rental, and customer tables.*/

select *from film;
select film.title, customer.first_name, customer.last_name
from 
film join inventory on film.film_id = inventory.film_id
join rental on inventory.inventory_id = rental.inventory_id
join customer on rental.customer_id = customer.customer_id;

/*Question 10:
Retrieve the names of all actors who have appeared in the film "Gone with the Wind."
Hint: Use JOIN between the film actor, film, and actor tables.*/
select actor.first_name , actor.last_name
from actor join film_actor on actor.actor_id = film_actor.actor_id
join film on film_actor.film_id = film.film_id
where film.title = 'Gone with the Wind';

/*Question 11:
Retrieve the customer names along with the total amount they've spent on rentals.
Hint: JOIN customer, payment, and rental tables, then use SUM() and GROUP BY.*/

SELECT
    customer.first_name,
    customer.last_name,
    SUM(payment.amount) AS total_spent
FROM
    customer
JOIN payment ON customer.customer_id = payment.customer_id
GROUP BY
    customer.customer_id,
    customer.first_name,
    customer.last_name
ORDER BY
    total_spent DESC;
    
    /*Question 12:
List the titles of movies rented by each customer in a particular city (e.g., 'London').
Hint: JOIN customer, address, city, rental, inventory, and film tables, then use GROUP BY.*/

SELECT
    customer.first_name,
    customer.last_name,
    film.title AS movie_title
FROM
    customer
JOIN address ON customer.address_id = address.address_id
JOIN city ON address.city_id = city.city_id
JOIN rental ON customer.customer_id = rental.customer_id
JOIN inventory ON rental.inventory_id = inventory.inventory_id
JOIN film ON inventory.film_id = film.film_id
WHERE
    city.city = 'London'
ORDER BY
    customer.last_name, customer.first_name, film.title;
    
    /*Advanced Joins and GROUP BY:*/
    
    /*Question 13:
Display the top 5 rented movies along with the number of times they've been rented.
Hint: JOIN film, inventory, and rental tables, then use COUNT () and GROUP BY, and limit the results*/

SELECT
    film.title AS movie_title,
    COUNT(rental.rental_id) AS times_rented
FROM
    film
JOIN inventory ON film.film_id = inventory.film_id
JOIN rental ON inventory.inventory_id = rental.inventory_id
GROUP BY
    film.film_id, film.title
ORDER BY
    times_rented DESC
LIMIT 5;

/*Question 14:
Determine the customers who have rented movies from both stores (store ID 1 and store ID 2).
Hint: Use JOINS with rental, inventory, and customer tables and consider COUNT() and GROUP BY.*/

SELECT
    customer.customer_id,
    customer.first_name,
    customer.last_name
FROM
    customer
JOIN rental ON customer.customer_id = rental.customer_id
JOIN inventory ON rental.inventory_id = inventory.inventory_id
GROUP BY
    customer.customer_id,
    customer.first_name,
    customer.last_name
HAVING
    COUNT(DISTINCT inventory.store_id) = 2;
    
/*Windows Function:*/

/*1. Rank the customers based on the total amount they've spent on rentals.*/
SELECT
    customer.customer_id,
    customer.first_name,
    customer.last_name,
    SUM(payment.amount) AS total_spent,
    RANK() OVER (ORDER BY SUM(payment.amount) DESC) AS spending_rank
FROM
    customer
JOIN payment ON customer.customer_id = payment.customer_id
GROUP BY
    customer.customer_id,
    customer.first_name,
    customer.last_name
ORDER BY
    total_spent DESC;
    
    /*2. Calculate the cumulative revenue generated by each film over time.*/
    SELECT
    film.title AS movie_title,
    rental.rental_date,
    SUM(payment.amount) OVER (
        PARTITION BY film.film_id
        ORDER BY rental.rental_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_revenue
FROM
    film
JOIN inventory ON film.film_id = inventory.film_id
JOIN rental ON inventory.inventory_id = rental.inventory_id
JOIN payment ON rental.rental_id = payment.rental_id
ORDER BY
    film.title,
    rental.rental_date;
    
    /*3. Determine the average rental duration for each film, considering films with similar lengths.*/
    SELECT
    film.length AS film_length_minutes,
    film.title,
    AVG(DATEDIFF(rental.return_date, rental.rental_date)) AS avg_rental_duration_days
FROM
    film
JOIN inventory ON film.film_id = inventory.film_id
JOIN rental ON inventory.inventory_id = rental.inventory_id
WHERE
    rental.return_date IS NOT NULL
GROUP BY
    film.length,
    film.title
ORDER BY
    film.length,
    film.title;
    
    /*4. Identify the top 3 films in each category based on their rental counts.*/
    SELECT 
    category_id,
    category_name,
    film_id,
    title,
    rental_count,
    rank_in_category
FROM (
    SELECT 
        c.category_id,
        c.name AS category_name,
        f.film_id,
        f.title,
        COUNT(r.rental_id) AS rental_count,
        DENSE_RANK() OVER (
            PARTITION BY c.category_id
            ORDER BY COUNT(r.rental_id) DESC
        ) AS rank_in_category
    FROM rental r
    JOIN inventory i ON r.inventory_id = i.inventory_id
    JOIN film f ON i.film_id = f.film_id
    JOIN film_category fc ON f.film_id = fc.film_id
    JOIN category c ON fc.category_id = c.category_id
    GROUP BY c.category_id, c.name, f.film_id, f.title
) ranked_films
WHERE rank_in_category <= 3
ORDER BY category_id, rank_in_category;
    
    
    /*5. Calculate the difference in rental counts between each customer's total rentals and the average rentals

across all customers.*/
SELECT customer_id, COUNT(*) AS total_rentals
FROM rental
GROUP BY customer_id;

SELECT AVG(customer_rentals.total_rentals) AS average_rentals
FROM (
    SELECT customer_id, COUNT(*) AS total_rentals
    FROM rental
    GROUP BY customer_id
) AS customer_rentals;

SELECT 
    customer_id,
    COUNT(*) AS total_rentals,
    COUNT(*) - avg_sub.avg_rentals AS difference_from_avg
FROM rental,
    (SELECT AVG(customer_rentals.total_rentals) AS avg_rentals
     FROM (
         SELECT customer_id, COUNT(*) AS total_rentals
         FROM rental
         GROUP BY customer_id
     ) AS customer_rentals) AS avg_sub
GROUP BY customer_id, avg_sub.avg_rentals;

/*6. Find the monthly revenue trend for the entire rental store over time.*/


SELECT 
    revenue_month,
    monthly_revenue,
    SUM(monthly_revenue) OVER (ORDER BY revenue_month) AS running_total_revenue
FROM (
    SELECT 
        DATE_FORMAT(payment_date, '%Y-%m') AS revenue_month,
        SUM(amount) AS monthly_revenue
    FROM payment
    GROUP BY DATE_FORMAT(payment_date, '%Y-%m')
) AS monthly_data
ORDER BY revenue_month;
    
/*7. Identify the customers whose total spending on rentals falls within the top 20% of all customers.*/

SELECT customer_id, total_spent
FROM (
    SELECT 
        customer_id,
        SUM(amount) AS total_spent,
        PERCENT_RANK() OVER (ORDER BY SUM(amount)) AS spending_percentile
    FROM payment
    GROUP BY customer_id
) ranked_customers
WHERE spending_percentile >= 0.80;

SELECT customer_id, total_spent
FROM (
    SELECT 
        customer_id,
        SUM(amount) AS total_spent,
        NTILE(5) OVER (ORDER BY SUM(amount)) AS spending_quintile
    FROM payment
    GROUP BY customer_id
) ranked_customers
WHERE spending_quintile = 5;

/*8. Calculate the running total of rentals per category, ordered by rental count.*/

SELECT 
    category_id,
    category_name,
    rental_count,
    SUM(rental_count) OVER (ORDER BY rental_count) AS running_total
FROM (
    SELECT 
        c.category_id,
        c.name AS category_name,
        COUNT(r.rental_id) AS rental_count
    FROM rental r
    JOIN inventory i ON r.inventory_id = i.inventory_id
    JOIN film f ON i.film_id = f.film_id
    JOIN film_category fc ON f.film_id = fc.film_id
    JOIN category c ON fc.category_id = c.category_id
    GROUP BY c.category_id, c.name
) AS category_rentals
ORDER BY rental_count;

/*9. Find the films that have been rented less than the average rental count for their respective categories.*/

SELECT 
    film_id,
    title,
    category_id,
    category_name,
    film_rental_count,
    avg_category_rental
FROM (
    SELECT 
        f.film_id,
        f.title,
        c.category_id,
        c.name AS category_name,
        COUNT(r.rental_id) AS film_rental_count,
        AVG(COUNT(r.rental_id)) OVER (PARTITION BY c.category_id) AS avg_category_rental
    FROM film f
    JOIN film_category fc ON f.film_id = fc.film_id
    JOIN category c ON fc.category_id = c.category_id
    LEFT JOIN inventory i ON f.film_id = i.film_id
    LEFT JOIN rental r ON i.inventory_id = r.inventory_id
    GROUP BY f.film_id, f.title, c.category_id, c.name
) AS film_stats
WHERE film_rental_count < avg_category_rental;

/*10. Identify the top 5 months with the highest revenue and display the revenue generated in each month.*/

SELECT 
    revenue_month,
    monthly_revenue
FROM (
    SELECT 
        DATE_FORMAT(payment_date, '%Y-%m') AS revenue_month,
        SUM(amount) AS monthly_revenue,
        RANK() OVER (ORDER BY SUM(amount) DESC) AS revenue_rank
    FROM payment
    GROUP BY DATE_FORMAT(payment_date, '%Y-%m')
) AS ranked_months
WHERE revenue_rank <= 5
ORDER BY monthly_revenue DESC;

/*Normalisation & CTE*/

/*1. First Normal Form (1NF):

 a. Identify a table in the Sakila database that violates 1NF. Explain how you

 would normalize it to achieve 1NF.*/
 /*Step 1: Simulate the 1NF Violation
Let’s create a bad table that violates 1NF by storing multiple phone numbers in one column:*/


CREATE TABLE customer_raw (
    customer_id INT PRIMARY KEY,
    full_name VARCHAR(100),
    phone_numbers TEXT
);
/*Insert fake non-atomic phone number data:*/


INSERT INTO customer_raw (customer_id, full_name, phone_numbers) VALUES
(1, 'Mary Smith', '111-111-1111,222-222-2222'),
(2, 'John Adams', '333-333-3333'),
(3, 'Alice Clark', '444-444-4444,555-555-5555,666-666-6666');
/*Step 2: Create 1NF-Compliant Normalized Tables
2A. Create normalized customer table (using Sakila’s structure):
We'll reuse the original customer table from Sakila (no need to recreate it).

2B. Create new customer_phone table:*/

CREATE TABLE customer_phone (
    phone_id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    phone_number VARCHAR(20),
    FOREIGN KEY (customer_id) REFERENCES customer(customer_id)
);
/*Step 3: Normalize Data from customer_raw
MySQL lacks a built-in SPLIT() function. So you'd normally use:

Stored procedure

Application-level split

Temporary manual INSERTs (if small dataset)*/

/*Manual insert (simulation for demo):*/

-- For customer_id = 1
INSERT INTO customer_phone (customer_id, phone_number) VALUES
(1, '111-111-1111'),
(1, '222-222-2222');

-- For customer_id = 2
INSERT INTO customer_phone (customer_id, phone_number) VALUES
(2, '333-333-3333');

-- For customer_id = 3
INSERT INTO customer_phone (customer_id, phone_number) VALUES
(3, '444-444-4444'),
(3, '555-555-5555'),
(3, '666-666-6666');
/* Step 4: View Normalized Data*/

SELECT c.customer_id, c.first_name, c.last_name, cp.phone_number
FROM customer c
JOIN customer_phone cp ON c.customer_id = cp.customer_id
ORDER BY c.customer_id;


/*2. Second Normal Form (2NF):

 a. Choose a table in Sakila and describe how you would determine whether it is in 2NF. 

 If it violates 2NF, explain the steps to normalize it*/
 
 /*Understanding Second Normal Form (2NF):
A table is in 2NF if:

It is already in First Normal Form (1NF) (i.e. atomic values, no repeating groups).

All non-key attributes are fully functionally dependent on the entire primary key — not just part of it.*/
/* Step 1: Choose a Table from Sakila — film_actor
Let’s take the film_actor table in the Sakila database as an example:*/
DESCRIBE film_actor;

/*Analysis:
Primary Key = (actor_id, film_id) — a composite key.

last_update depends on the combination of actor and film.

So: This table does not violate 2NF, because last_update depends on the entire key.*/

/*Let’s Simulate a 2NF Violation:
Imagine we modify the film_actor table and add a non-key attribute like actor_name:*/

CREATE TABLE film_actor_bad (
    actor_id INT,
    film_id INT,
    actor_name VARCHAR(100), -- violates 2NF
    PRIMARY KEY (actor_id, film_id)
);

/*Now:

actor_name depends only on actor_id, not the full composite key.

❌ This violates 2NF because it’s partially dependent.*/

/* 2: Normalize to 2NF
Split into two tables:

✅ 1. film_actor (relationship table)*/

select *from film_actor;
CREATE TABLE film_actor_normalized (
    actor_id SMALLINT UNSIGNED NOT NULL,
    film_id SMALLINT UNSIGNED NOT NULL,
    PRIMARY KEY (actor_id, film_id),
    FOREIGN KEY (actor_id) REFERENCES actor(actor_id),
    FOREIGN KEY (film_id) REFERENCES film(film_id)
);

SELECT actor_id, first_name, last_name FROM actor;

INSERT INTO film_actor_normalized (actor_id, film_id)
SELECT actor_id, film_id FROM film_actor_bad;
#Final Query (Normalized Result):
SELECT 
    fa.actor_id,
    CONCAT(a.first_name, ' ', a.last_name) AS actor_name,
    fa.film_id,
    f.title AS film_title
FROM film_actor_normalized fa
JOIN actor a ON fa.actor_id = a.actor_id
JOIN film f ON fa.film_id = f.film_id;

/*3. Third Normal Form (3NF):

 a. Identify a table in Sakila that violates 3NF. Describe the transitive dependencies 

 present and outline the steps to normalize the table to 3NF.*/
 
 DESCRIBE address;
 DESCRIBE city;
 -- Denormalized structure (violates 3NF)
CREATE TABLE address_denorm (
    address_id   INT PRIMARY KEY,
    address      VARCHAR(50),
    city_id      INT,
    city         VARCHAR(50),
    country_id   INT,
    country      VARCHAR(50)
);

select *from country;

/*4. Normalization Process:

 a. Take a specific table in Sakila and guide through the process of normalizing it from the initial 

 unnormalized form up to at least 2NF.*/
 
 /*1. Unnormalized Form (UNF)
Imagine a version of rental that stores repeating groups and redundant data:*/

CREATE TABLE rental_unf (
    rental_id      INT,
    rental_date    DATETIME,
    customer_id    INT,
    customer_name  VARCHAR(100),
    film_titles    TEXT,  -- comma-separated list (e.g., "Alien, Matrix, Shrek")
    amount_paid    DECIMAL(5,2)
);

/*Problems:
film_titles is a repeating group – violates 1NF.

customer_name is redundant – depends on customer_id.*/

/*2. First Normal Form (1NF)
Goal: Remove repeating groups. Each field must contain only atomic values.

We split each film into a separate row:*/

CREATE TABLE rental_1nf (
    rental_id      INT,
    rental_date    DATETIME,
    customer_id    INT,
    customer_name  VARCHAR(100),
    film_title     VARCHAR(100),
    amount_paid    DECIMAL(5,2)
);
/*Changes:
film_titles is split into film_title, one film per row.

Still not 2NF because customer_name depends on only part of the key (customer_id), not the whole row.*/

/*3. Second Normal Form (2NF)
Goal: Remove partial dependencies – every non-key attribute must depend on the whole primary key.

Assume the composite primary key is (rental_id, film_title)

❌ Problem:
customer_name depends only on customer_id, not the full primary key.

✅ Fix: Split into two tables

l (core rental info)*/

CREATE TABLE rental_2nf (
    rental_id      INT PRIMARY KEY,
    rental_date    DATETIME,
    customer_id    INT,
    amount_paid    DECIMAL(5,2)
);

/*Table 2: rental_film (connects rental to films)*/

CREATE TABLE rental_film (
    rental_id   INT,
    film_title  VARCHAR(100),
    PRIMARY KEY (rental_id, film_title),
    FOREIGN KEY (rental_id) REFERENCES rental_2nf(rental_id)
);

/* Table 3: customer (stores customer details)*/

CREATE TABLE customer_2nf (
    customer_id    INT PRIMARY KEY,
    customer_name  VARCHAR(100)
);

/*Q5. CTE Basics:

 a. Write a query using a CTE to retrieve the distinct list of actor names and the number of films they 

 have acted in from the actor and film_actor tables.*/
 
 -- Using a CTE to calculate film counts per actor
WITH actor_film_count AS (
    SELECT
        fa.actor_id,
        COUNT(DISTINCT fa.film_id) AS film_count
    FROM film_actor fa
    GROUP BY fa.actor_id
)

SELECT
    a.actor_id,
    CONCAT(a.first_name, ' ', a.last_name) AS actor_name,
    afc.film_count
FROM actor a
JOIN actor_film_count afc ON a.actor_id = afc.actor_id
ORDER BY afc.film_count DESC;

/*Q6. CTE with Joins:

 a. Create a CTE that combines information from the film and language tables to display the film title, 

 language name, and rental rate.*/
 
 -- CTE to join film and language tables
WITH film_language_cte AS (
    SELECT
        f.film_id,
        f.title AS film_title,
        l.name AS language_name,
        f.rental_rate
    FROM film f
    JOIN language l ON f.language_id = l.language_id
)

-- Final SELECT from the CTE
SELECT
    film_title,
    language_name,
    rental_rate
FROM film_language_cte
ORDER BY film_title;

/*Q7 CTE for Aggregation:

 a. Write a query using a CTE to find the total revenue generated by each customer (sum of payments) 

 from the customer and payment tables.*/
 
 -- CTE to calculate total payment per customer
WITH customer_revenue AS (
    SELECT
        p.customer_id,
        SUM(p.amount) AS total_revenue
    FROM payment p
    GROUP BY p.customer_id
)

-- Final SELECT with customer details
SELECT
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    cr.total_revenue
FROM customer c
JOIN customer_revenue cr ON c.customer_id = cr.customer_id
ORDER BY cr.total_revenue DESC;

/*Q8 CTE with Window Functions:

 a. Utilize a CTE with a window function to rank films based on their rental duration from the film table.*/

-- CTE to apply ranking on rental_duration
WITH film_ranks AS (
    SELECT
        film_id,
        title,
        rental_duration,
        RANK() OVER (ORDER BY rental_duration DESC) AS rental_rank
    FROM film
)

-- Final SELECT from the CTE
SELECT
    film_id,
    title,
    rental_duration,
    rental_rank
FROM film_ranks
ORDER BY rental_rank, title;

/*Q9\ CTE and Filtering:

 a. Create a CTE to list customers who have made more than two rentals, and then join this CTE with the 

 customer table to retrieve additional customer details.*/
 
 -- CTE to count rentals per customer and filter those with more than 2
WITH frequent_renters AS (
    SELECT
        customer_id,
        COUNT(*) AS rental_count
    FROM rental
    GROUP BY customer_id
    HAVING rental_count > 2
)

-- Join the CTE with the customer table to get full details
SELECT
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    c.email,
    fr.rental_count
FROM customer c
JOIN frequent_renters fr ON c.customer_id = fr.customer_id
ORDER BY fr.rental_count DESC;

/*Q10CTE for Date Calculations:

 a. Write a query using a CTE to find the total number of rentals made each month, considering the 

 rental_date from the rental table*/
 
 -- CTE to extract month and year from rental_date
WITH monthly_rentals AS (
    SELECT
        DATE_FORMAT(rental_date, '%Y-%m') AS rental_month,
        COUNT(*) AS total_rentals
    FROM rental
    GROUP BY rental_month
)

-- Final SELECT
SELECT
    rental_month,
    total_rentals
FROM monthly_rentals
ORDER BY rental_month;

/*Q11CTE and Self-Join:

 a. Create a CTE to generate a report showing pairs of actors who have appeared in the same film 

 together, using the film_actor table.*/
 
 -- CTE to select all actor-film relationships
WITH actor_films AS (
    SELECT
        film_id,
        actor_id
    FROM film_actor
)

-- Self-join the CTE to find pairs of actors in the same film
SELECT
    af1.actor_id AS actor_1_id,
    af2.actor_id AS actor_2_id,
    af1.film_id
FROM actor_films af1
JOIN actor_films af2 
    ON af1.film_id = af2.film_id
    AND af1.actor_id < af2.actor_id  -- Avoid duplicates and self-pairing
ORDER BY film_id, actor_1_id, actor_2_id;

/*Q12.CTE for Recursive Search:

 a. Implement a recursive CTE to find all employees in the staff table who report to a specific manager, 

 considering the reports_to column*/
 
 ALTER TABLE staff ADD COLUMN reports_to SMALLINT NULL;
 
 WITH RECURSIVE staff_hierarchy AS (
    SELECT
        staff_id,
        first_name,
        last_name,
        reports_to
    FROM staff
    WHERE staff_id = 2  -- change 2 to your manager's staff_id

    UNION ALL

    SELECT
        s.staff_id,
        s.first_name,
        s.last_name,
        s.reports_to
    FROM staff s
    INNER JOIN staff_hierarchy sh ON s.reports_to = sh.staff_id
)

SELECT
    staff_id,
    CONCAT(first_name, ' ', last_name) AS employee_name,
    reports_to
FROM staff_hierarchy
WHERE staff_id != 2
ORDER BY staff_id;